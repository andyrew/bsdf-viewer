<!DOCTYPE html>
<meta charset="utf-8">
<style>

text {
  font-family: Roboto, sans-serif;
  font-size: 9px;
  text-anchor: middle;
}

#wrapper {
    width: 900px;
  	height: 600px;
    overflow: hidden;
}
  
#controlPanel {
    width: 300px;
  	height: 500px;
    float:left;
}
  
#viewer {
  	height: 500px;
    overflow: hidden;
}
</style>

<body>
<div id="wrapper">
    <div id="controlPanel">
    <div id="vtitle" style="font-size: 20px">BSDF Viewer</div>
    <br>
    <input type="file" id="fileinput" style="width:200px;"> </input>
    <div id="filename"></div>
    <br>
    <div id="direction"></div>
  	<div id="selecteddir"></div>  
  	<div id="selectedpatch"></div>  
  	<div id="patchvalue"></div>  
  	<hr>
    <div id="info"  style="color: gray">
      <p> Hover on each patch to see the values. Click on each patch to updated the values based on the new angle of incident.</p>
      <p>Report bugs and suggestions to (mostapha@ladybug.tools)</p>
      <p style="color: red"> Known bug: 1. The legend needs to be fixed.</p>
      <p style="color: red"> 2. select doesn't update to the selected option when loading a new file.</p>
      <p style="color: red"> 3. Numbers mapping shold be double checked. The id and hence the values for the same patch is different based on direction.</p>
  	</div>
  	</div>
    <div id="viewer"></div>
</div>
</body>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="loadbsdf.js"></script>
<script src="legend.js"></script>
<script src="add_direction_select.js"></script>

<script>

  var pcount = [1, 8, 16, 20, 24, 24, 24, 16, 12],
      counter = [1, 9, 25, 45, 69, 93, 117, 133, 145],
      counter_rev = [145, 133, 117, 93, 69, 45, 25, 9, 1],
      scale = [0.5, 1, 1, 1, 1, 1, 1, 1],
      radius = [0.5, 1, 1, 1, 1, 1, 1, 1, 2];

  var width = 960,
      chwidth = 600,
      height = 500,
      cwidth = 22.5,
      PI2 = 2 * Math.PI
      HPI = Math.PI / 2,
      selectedPatch = 1;
			selectedDirection = 0;

//Base the color scale on trans / reflectance values
var color = d3.scaleLog()
  .domain([0.00000001, 0.5, 100])
  .range(["#2c7bb6", "#ffff8c", "#d7191c"]);

// assign readXMLfile to browse file
document.getElementById('fileinput').onchange = function(evt) {readXMLFile(evt.target.files[0]);};

// initiate page
function init_page(parsed_data){

  directions = parsed_data.map(function(d){ return d.direction; });
  var data = []

  // each ring
  for (i = 0; i < pcount.length; i++){
    // each direction inside the ring
    var count = pcount[i]
    // scale for ring depth
    var sum = scale.slice(0, i).reduce((a, b) => a + b, 0);
    var angle = PI2 / count;
    var selected = i == 0 ? true : false;  

    for (j = 0; j < count; j++){
      var id = i == 0 ? 1: counter[i - 1] + j + 1;
      // initiate data for each patch
      data.push({'id': id, 'selected': selected,
                 'values': parsed_data.map(function(d){ return d.data.map(function(el){return el[getIdByDirection(id) - 1];})}),
                 'value': parsed_data[selectedDirection].data[selectedPatch - 1][getIdByDirection(id) - 1],
                 'startAngle': (j - 0.5) * angle - HPI,
                 'endAngle': (j + 0.5) * angle - HPI,
                 'innerRadius': cwidth * sum,
                 'outerRadius': cwidth * (sum + radius[i])})
    }
  }


  var arc = d3.arc();

  var label = d3.arc();

  var svg = d3.select("body").select("#viewer").append("svg")
      .attr("width", width)
      .attr("height", height)
      .append("g")
      .attr("transform", "translate(" + chwidth / 2 + "," + ((height / 2) - 30) + ")");

  var ring = svg.selectAll(".ring")
      .data(data)
      .enter().append("g")
        .attr("class", "ring")
        .style("cursor", "pointer");

  ring.append("path")
      .attr("class", "patch")
      .attr("fill", function(d) { return color(d.value); })
      .attr("stroke", 'black')
      .attr("stroke-width", function(d) { return d.selected ? 3 : 1; })  
      .attr("d", function(d) {
          return arc
            .innerRadius(d.innerRadius)
            .outerRadius(d.outerRadius)
            .startAngle(d.startAngle)
            .endAngle(d.endAngle)(); })
      .on('click', update_graph_on_click);

  ring.append("svg:title")
  		.attr("class", "patchtitle")
      .text(function(d) { return d.value; });

  ring.append("text")
  			.attr("class", "patch_id")
        .attr("transform", function(d) { 
          return d.id == 1 ? "translate(0,0)" : "translate(" + 			
  
  label.centroid(d) + ")";})
        .attr("dy", "0.35em")
  			.attr("fill", "black")
        .text(function(d) { return getIdByDirection(d.id); });
  
  draw_legend();
  d3.select("div #filename").text(bsdf_path).style("color", "gray");
  add_directions_dropdown(directions);
  // add data as text
  d3.select("div #selectedpatch").text("Incident Patch: " + selectedPatch);
}

// calculate ring number from patch front id
function ringNumber(frontId){
    if (frontId == 1) return 0;
  	for (var i = 0; i < counter_rev.length; i++){
        var v = counter_rev[i];
      	if (frontId > v) return 9 - i;
		}
}

//get backId of the patch from the front value
function backId(frontId){
    if (frontId == 1){ return 1; }
    var rn = ringNumber(frontId)  // ring number
    var n = pcount[rn]  // number of patches in this ring
    var i = frontId - (counter[rn - 1] + 1)  // number of this patch in this ring
    var a = 2 * Math.PI / n
    var offset = 2 * Math.min(Math.abs(i - (n / 4)), Math.abs(i - 3 * (n / 4)))
    if (Math.tan(i * a) < 0){ offset *= -1; }
    return frontId + offset
}

function getIdByDirection(frontId){
  if (isDirectionFront()) return frontId;
  return backId(frontId);
}

function isDirectionFront(){
  return directions[selectedDirection].endsWith('Front');
}

function update_graph_on_click(){
  var p = d3.select(this);
  var data = p.data()[0];
  selectedPatch = getIdByDirection(data.id);
  d3.selectAll(".patch")
  	.attr("stroke-width", 1)
    .attr("fill", function(d) {
    	d.selected = false;
    	d.value = d.values[selectedDirection][selectedPatch - 1];
    	return color(d.value); });
  
  d3.selectAll(".patchtitle").text(function(d) { return d.value; });
  data.selected = true;
  p.attr("stroke-width", 3);
  d3.select("div #selectedpatch").text("Incident Patch: " + selectedPatch);
}

function update_graph_direction(){
  d3.selectAll(".patch")
    .attr("fill", function(d) {
    	d.value = d.values[selectedDirection][selectedPatch - 1];
    	return color(d.value); });
  
  d3.selectAll(".patchtitle").text(function(d) { return d.value; });
  d3.selectAll("text.patch_id").text(function(d) { return getIdByDirection(d.id); });
}
  
function update_on_new_file(parsed_data){
  
  directions = parsed_data.map(function(d){ return d.direction; });
  selectedDirection = selectedDirection % directions.length;
  add_directions_dropdown(directions);
  d3.select("div #selecteddir").text(directions[selectedDirection]);
  
	// update data
  d3.selectAll(".patch").data().forEach(
    function(da){
      da.values = parsed_data.map(function(d){
        return d.data.map(
          function(el){return el[getIdByDirection(da.id) - 1];}
        )});
    }
  ); 
  
  d3.selectAll(".patch")
    .attr("fill", function(d) {
    	d.value = d.values[selectedDirection][selectedPatch - 1];
    	return color(d.value); });
  
  d3.selectAll(".patchtitle").text(function(d) { return d.value; });
  d3.select("div #filename").text('');
}

// load default bsdf
var bsdf_path = "cl_Tn0.06_blinds.xml";
load_xml_file(bsdf_path, init_page);
</script>