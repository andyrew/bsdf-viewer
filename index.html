<!DOCTYPE html>
<meta charset="utf-8">
<!-- Google Font -->
	<link href='https://fonts.googleapis.com/css?family=Open+Sans:300,400' rel='stylesheet' type='text/css'>

<style>

text {
  font-family: 'Open Sans', sans-serif;
  font-size: 9px;
  text-anchor: middle;
}

#wrapper {
    width: 900px;
  	height: 600px;
    overflow: hidden;
}
  
#controlPanel {
    width: 300px;
  	height: 500px;
    float:left;
}
  
#viewer {
  	height: 500px;
    overflow: hidden;
}
</style>

<body>
<div id="wrapper">
    <div id="controlPanel">
    <div id="vtitle" style="font-size: 20px">BSDF Viewer</div>
    <br>
    <input type="file" id="fileinput" style="width:200px;"> </input>
    <div id="filename"></div>
    <br>
    <div id="direction"></div>
    <br>
  	<div id="selecteddir"></div>  
  	<div id="totalvalue"></div>  
  	<div id="selectedpatch"></div>  
  	<hr>
    <div id="info"  style="color: gray">
      <p> How to use this viewer: </p>
      <p>1. Click on each patch to updat the values based on the new angle of incident.<br>2. Hover on each patch to see the values.</p>
      <p style="color: orange">NOTE: The viewer currently dose NOT support Tensor Tree BSDFs.</p>
      <p>Report bugs and suggestions to (https://github.com/ladybug-tools/honeybee/issues)</p>
      <p style="color: red"></p>
  	</div>
  	</div>
    <div id="viewer"></div>
</div>
</body>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="loadbsdf.js"></script>
<script src="legend.js"></script>
<script src="add_direction_select.js"></script>

<script>

  var pcount = [1, 8, 16, 20, 24, 24, 24, 16, 12],
      counter = [1, 9, 25, 45, 69, 93, 117, 133, 145],
      counter_rev = [145, 133, 117, 93, 69, 45, 25, 9, 1],
      scale = [0.5, 1, 1, 1, 1, 1, 1, 1],
      radius = [0.5, 1, 1, 1, 1, 1, 1, 1, 2];

  var width = 960,
      chwidth = 600,
      height = 500,
      cwidth = 22.5,
      PI2 = 2 * Math.PI
      HPI = Math.PI / 2,
      selectedPatch = 1, // this is not the id but the correct id which is selected
			selectedDirection = 0;

//Base the color scale on trans / reflectance values
var color = d3.scaleLog()
  .domain([0.00000001, 50, 100])
  .range(["#2c7bb6", "#ffff8c", "#d7191c"]);

// assign readXMLfile to browse file
document.getElementById('fileinput').onchange = function(evt) {readXMLFile(evt.target.files[0]);};

///////////////////
///initiate page///
///////////////////
function init_page(parsed_data){

  directions = parsed_data.map(function(d){ return d.direction; });
  var data = [];

  // each ring
  for (i = 0; i < pcount.length; i++){
    // each direction inside the ring
    var count = pcount[i];
    // scale for ring depth
    var sum = scale.slice(0, i).reduce((a, b) => a + b, 0);
    var angle = PI2 / count;
    var selected = i == 0 ? true : false;  

    for (j = 0; j < count; j++){
      var id = i == 0 ? 1: counter[i - 1] + j + 1;
      // initiate data for each patch
      data.push(
        {'id': id,  // id of patches 1..145
         'selected': selected,
         'values': parsed_data.map(function(d, i){
           	var dirc = directions[i];
          	return d.data.map(function(el){return +el[getIdByDirection(id, dirc) - 1];})
         }),
         'value': parsed_data[selectedDirection].data[selectedPatch - 1][id - 1],
         'startAngle': (j - 0.5) * angle - HPI,
         'endAngle': (j + 0.5) * angle - HPI,
         'innerRadius': cwidth * sum,
         'outerRadius': cwidth * (sum + radius[i])})
    }
  }


  var arc = d3.arc();

  var label = d3.arc();

  var svg = d3.select("body").select("#viewer").append("svg")
      .attr("width", width)
      .attr("height", height)
      .append("g")
      .attr("transform", "translate(" + chwidth / 2 + "," + ((height / 2) - 30) + ")");

  var ring = svg.selectAll(".ring")
      .data(data)
      .enter().append("g")
        .attr("class", "ring")
        .style("cursor", "pointer");

  ring.append("path")
      .attr("class", "patch")
      .attr("fill", function(d) { return color(d.value); })
      .attr("stroke", 'black')
      .attr("stroke-width", function(d) { return d.selected ? 3 : 1; })  
      .attr("d", function(d) {
          return arc
            .innerRadius(d.innerRadius)
            .outerRadius(d.outerRadius)
            .startAngle(d.startAngle)
            .endAngle(d.endAngle)(); })
      .on('click', update_graph_on_click);

  ring.append("svg:title")
  		.attr("class", "patchtitle")
      .text(function(d) { return d.value; });

  ring.append("text")
  			.attr("class", "patch_id")
        .attr("transform", function(d) { 
          return d.id == 1 ? "translate(0,0)" : "translate(" + 			
  
  label.centroid(d) + ")";})
        .attr("dy", "0.35em")
  			.attr("fill", "black")
        .text(function(d) { return getIdByDirection(d.id); });
  
  draw_legend();
  d3.select("div #filename").text(bsdf_path).style("color", "gray");
  add_directions_dropdown(directions);
  // add data as text
  updateCPText(data[selectedPatch - 1].value);
}


// update patch data in control panel
function updateCPText(value){
  d3.select("div #selecteddir").text(directions[selectedDirection]);
  d3.select("div #selectedpatch").text(
    "Incident Patch: " + selectedPatch + " || Value: " + value + "%");
  
  var total = 0;
  d3.selectAll(".patch").data().forEach(function(d){ total += d.value; });
  d3.select("div #selecteddir").text(directions[selectedDirection]);
  d3.select("div #totalvalue").text("Total: " + total);
}
  
// calculate ring number from patch front id
function ringNumber(frontId){
    if (frontId == 1) return 0;
  	for (var i = 0; i < counter_rev.length; i++){
        var v = counter_rev[i];
      	if (frontId > v) return 9 - i;
		}
}

//get backId of the patch from the front value
function backId(frontId){
    if (frontId == 1){ return 1; }
    var rn = ringNumber(frontId)  // ring number
    var n = pcount[rn]  // number of patches in this ring
    var i = frontId - (counter[rn - 1] + 1)  // number of this patch in this ring
    var a = 2 * Math.PI / n
    var offset = 2 * Math.min(Math.abs(i - (n / 4)), Math.abs(i - 3 * (n / 4)))
    if (Math.tan(i * a) < 0){ offset *= -1; }
    return frontId + offset
}

function getIdByDirection(frontId, dirc){
  if (isDirectionFront(dirc)) return frontId;
  return backId(frontId);
}

function isDirectionFront(dirc){
  var d = dirc || directions[selectedDirection];
  return d.endsWith('Front');
}

function update_graph_on_click(){
  var p = d3.select(this);
  var data = p.data()[0];
  selectedPatch = getIdByDirection(data.id);
  d3.selectAll(".patch")
  	.attr("stroke-width", 1)
    .attr("fill", function(d) {
    	d.selected = false;
    	d.value = d.values[selectedDirection][selectedPatch - 1];
    	return color(d.value); });
  
  d3.selectAll(".patchtitle").text(function(d) { return d.value; });
  data.selected = true;
  p.attr("stroke-width", 3);
  updateCPText(data.value);
}

function update_on_new_file(parsed_data){
  var v = null;
  directions = parsed_data.map(function(d){ return d.direction; });
  selectedDirection = selectedDirection % directions.length;
  add_directions_dropdown(directions);
  
	// update data
  d3.selectAll(".patch").data().forEach(
    function(da){
      da.values = parsed_data.map(function(d, i){
        var dirc = directions[i];
        return d.data.map(
          function(el){return el[getIdByDirection(da.id, dirc) - 1];}
        )});
    }
  ); 
  
  d3.selectAll(".patch")
    .attr("fill", function(d) {
    	d.value = d.values[selectedDirection][selectedPatch - 1];
    	if (getIdByDirection(d.id) == selectedPatch) v = d.value;
    	return color(d.value); });
  
  d3.selectAll(".patchtitle").text(function(d) { return d.value; });
  d3.select("div #filename").text('');
  updateCPText(v); // this should be fixed
}

// load default bsdf
var bsdf_path = "SingleClear.xml";
// var bsdf_path = "CS-TBK7-12_112916.xml";
// var bsdf_path = "cl_Tn0.06_blinds.xml";
load_xml_file(bsdf_path, init_page);
</script>