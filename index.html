<!DOCTYPE html>
<meta charset="utf-8">
<style>

text {
  font-family: Roboto, sans-serif;
  font-size: 9px;
  text-anchor: middle;
}

#wrapper {
    width: 900px;
  	height: 600px;
    overflow: hidden;
}
  
#controlPanel {
    width: 300px;
  	height: 500px;
    float:left;
}
  
#viewer {
  	height: 500px;
    overflow: hidden;
}
</style>

<body>
<div id="wrapper">
    <div id="controlPanel">
    <div id="vtitle" style="font-size: 20px">BSDF Viewer</div>
    <br>
    <input type="file" id="fileinput" style="width:200px;"> </input>
    <div id="filename"></div>
    <br>
    <div id="direction"></div>
  	</div>
    <div id="viewer"></div>
</div>
</body>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="loadbsdf.js"></script>
<script src="legend.js"></script>
<script src="add_direction_select.js"></script>

<script>

  var pcount = [1, 8, 16, 20, 24, 24, 24, 16, 12],
      counter = [1, 9, 25, 45, 69, 93, 117, 133, 145],
      scale = [0.5, 1, 1, 1, 1, 1, 1, 1],
      radius = [0.5, 1, 1, 1, 1, 1, 1, 1, 2];

  var width = 960,
      chwidth = 600,
      height = 500,
      cwidth = 22.5,
      PI2 = 2 * Math.PI
      HPI = Math.PI / 2,
      selectedPatch = 1;
			selectedDirection = 0;

//Base the color scale on trans / reflectance values
var color = d3.scaleLinear()
  .domain([0, 0.0005, 1])
  .range(["#2c7bb6", "#ffff8c", "#d7191c"])
  .interpolate(d3.interpolateHcl);

// assign readXMLfile to browse file
document.getElementById('fileinput').onchange = function(evt) {readXMLFile(evt.target.files[0]);};

// initiate page
function init_page(parsed_data){

  var directions = parsed_data.map(function(d){ return d.direction; });
  var data = []

  // each ring
  for (i = 0; i < pcount.length; i++){
    // each direction inside the ring
    var count = pcount[i]
    // scale for ring depth
    var sum = scale.slice(0, i).reduce((a, b) => a + b, 0);
    var angle = PI2 / count;
    var selected = i == 0 ? true : false;  

    for (j = 0; j < count; j++){
      var id = i == 0 ? 1: counter[i - 1] + j + 1;
      // initiate data for each patch
      data.push({'id': id, 'selected': selected,
                 'values': parsed_data.map(function(d){ return d.data.map(function(el){return el[id - 1];})}),
                 'value': parsed_data[selectedDirection].data[selectedPatch - 1][id - 1],
                 'startAngle': (j - 0.5) * angle - HPI,
                 'endAngle': (j + 0.5) * angle - HPI,
                 'innerRadius': cwidth * sum,
                 'outerRadius': cwidth * (sum + radius[i])})
    }
  }


  var arc = d3.arc();

  var label = d3.arc();

  var svg = d3.select("body").select("#viewer").append("svg")
      .attr("width", width)
      .attr("height", height)
      .append("g")
      .attr("transform", "translate(" + chwidth / 2 + "," + ((height / 2) - 30) + ")");

  var ring = svg.selectAll(".ring")
      .data(data)
      .enter().append("g")
        .attr("class", "ring")
        .style("cursor", "pointer");

  ring.append("path")
      .attr("class", "patch")
      .attr("fill", function(d) { return color(d.value); })
      .attr("stroke", 'black')
      .attr("stroke-width", function(d) { return d.selected ? 3 : 1; })  
      .attr("d", function(d) {
          return arc
            .innerRadius(d.innerRadius)
            .outerRadius(d.outerRadius)
            .startAngle(d.startAngle)
            .endAngle(d.endAngle)(); })
      .on('click', update_graph_on_click);

  ring.append("svg:title")
  		.attr("class", "patchtitle")
      .text(function(d) { return d.value; });

  ring.append("text")
        .attr("transform", function(d) { 
          return d.id == 1 ? "translate(0,0)" : "translate(" + 			
  
  label.centroid(d) + ")";})
        .attr("dy", "0.35em")
  			.attr("fill", "black")
  			//.attr("stroke", "white")
  			//.attr("stroke-width", 0.3)
        .text(function(d) { return d.id; });
  
  draw_legend();
  d3.select("div #filename").text(bsdf_path).style("color", "gray");
  add_directions_dropdown(directions);
}

function update_graph_on_click(){
  var p = d3.select(this);
  var data = p.data()[0];
  d3.selectAll(".patch")
  	.attr("stroke-width", 1)
    .attr("fill", function(d) {
    	d.selected = false;
    	d.value = d.values[selectedDirection][data.id - 1];
    	return color(d.value); });
  
  d3.selectAll(".patchtitle").text(function(d) { return d.value; });
  selectedPatch = data.id;
  data.selected = true;
  p.attr("stroke-width", 3);
}

function update_graph_direction(){
  d3.selectAll(".patch")
    .attr("fill", function(d) {
    	d.value = d.values[selectedDirection][selectedPatch - 1];
    	return color(d.value); });
  
  d3.selectAll(".patchtitle").text(function(d) { return d.value; });
}
  
function update_on_new_file(parsed_data){
	// update data
  d3.selectAll(".patch").data().forEach(
    function(da){
      da.values = parsed_data.map(function(d){
        return d.data.map(function(el){return el[da.id - 1];})});;});
  
  d3.selectAll(".patch")
    .attr("fill", function(d) {
    	d.value = d.values[selectedDirection][selectedPatch - 1];
    	return color(d.value); });
  
  d3.selectAll(".patchtitle").text(function(d) { return d.value; });
  d3.select("div #filename").text('');
} 

// load default bsdf
var bsdf_path = "cl_Tn0.06_blinds.xml";
load_xml_file(bsdf_path, init_page);
</script>