<!DOCTYPE html>
<meta charset="utf-8">
<!-- Google Font -->
	<!-- <link href='https://fonts.googleapis.com/css?family=Open+Sans:300,400' rel='stylesheet' type='text/css'> -->

<style>

text {
  font-family: 'Open Sans', sans-serif;
  font-size: 9px;
  text-anchor: middle;
  user-select: none;
  cursor: none;
}

#wrapper {
    width: 1080px;
  	height: 800px;
    overflow: hidden;
}

#wrapper:after {
  content: "";
  display: table;
  clear: both;
}
  
#controlPanel {
    width: 400px;
  	height: 500px;
    float:left;
}
  
#viewer {
    width: 600px;
  	height: 500px;
    float: left;
}

#legend {
    position: relative;
  	height: 500px;
    float: left;
}
</style>

<body>
<div id="wrapper">
    <div id="controlPanel">
      <div id="vtitle" style="font-size: 20px">BSDF Viewer</div>
      <br>
      <input type="file" id="fileinput" style="width:200px;"> </input>
      <div id="filename"></div>
      <br>
      <div id="direction"></div>
      <br>
      <div id="selecteddir"></div>  
      <div id="totalvalue"></div>  
      <div id="selectedpatch"></div>  
      <hr>
      <div>Incident Hemisphere</div>
      <div id="incident"></div>
      <hr>
    </div>
    <div id="viewer"></div>
    <div id="legend"></div>
    <div id="info"  style="color: gray">
      <p> How to use this viewer: </p>
      <p>1. Click on each patch to update the values based on the new angle of incident.<br>2. Hover on each patch to see the values.</p>
      <p style="color: orange">NOTE: The viewer currently dose NOT support Tensor Tree BSDFs.</p>
      <p>Report bugs and suggestions to (https://github.com/ladybug-tools/honeybee/issues)</p>
      <p style="color: red"></p>
  	</div>
</div>
</body>
<script src="libs/d3.v4.min.js"></script>
<script src="libs/loadbsdf.js"></script>
<script src="libs/legend.js"></script>
<script src="libs/add_direction_select.js"></script>

<script>

  // TODO:
  // fix legend range

  var pcount = [1, 8, 16, 20, 24, 24, 24, 16, 12],           // number of patches
      counter = [1, 9, 25, 45, 69, 93, 117, 133, 145],       // counter for each ring
      counter_rev = [145, 133, 117, 93, 69, 45, 25, 9, 1],   // same but reversed 
      scale = [0.5, 1, 1, 1, 1, 1, 1, 1],                    // not sure how I use this?
      radius = [0.5, 1, 1, 1, 1, 1, 1, 1, 2];                // arc radius for each ring

  var width = 600,
      chwidth = 600,
      height = 500,
      cwidth = 22.5,
      PI2 = 2 * Math.PI
      HPI = Math.PI / 2,
      selectedPatch = 1,      // this is not the id but the correct id which is selected
			selectedDirection = 0;

//Base the color scale on trans / reflectance values
var log_scale = d3.scaleLog().domain([1e-6, 100])
var color = d3.scaleSequential((d) => d3.interpolatePlasma(log_scale(d)));

// assign readXMLfile to browse file
document.getElementById('fileinput').onchange = function(evt) {readXMLFile(evt.target.files[0]);};

///////////////////
///initiate page///
///////////////////
function init_page(parsed_data){

  directions = parsed_data.map(function(d){ return d.direction; });

  var data = [], 
    inp_data = [];

  // each ring
  for (i = 0; i < pcount.length; i++){
    // each direction inside the ring
    var count = pcount[i];
    // scale for ring depth
    var sum = scale.slice(0, i).reduce((a, b) => a + b, 0);
    var angle = PI2 / count;
    var selected = i == 0 ? true : false;  

    for (j = 0; j < count; j++){
      var id = i == 0 ? 1: counter[i - 1] + j + 1;
      // initiate data for each patch for exiting hemisphere
      data.push(
        {'id': id,  // id of patches 1..145
         'values': parsed_data.map(function(d, i){
            var dirc = directions[i];
          	return d.data.map(
              function(el){
                return +el[id - 1];
              })
         }),
         'value': parsed_data[selectedDirection].data[selectedPatch - 1][id - 1],
         'startAngle': (j - 0.5) * angle - HPI,
         'endAngle': (j + 0.5) * angle - HPI,
         'innerRadius': cwidth * sum,
         'outerRadius': cwidth * (sum + radius[i])
         }
      )

      inp_data.push(
        {'id': id,  // id of patches 1..145
         'selected': selected,
         'startAngle': (j + 0.5) * angle + HPI,
         'endAngle': (j - 0.5) * angle + HPI,
         'innerRadius': cwidth / 2 * sum,
         'outerRadius': cwidth / 2 * (sum + radius[i])
         }
      )
    }
  }


  var arc = d3.arc();

  var label = d3.arc();

  var svg = d3.select("body").select("#viewer").append("svg")
      .attr("width", width)
      .attr("height", height)
      .append("g")
      .attr("transform", "translate(" + width / 2  +  "," + height / 2 + ")");

  var inp_svg =  d3.select("body").select("#incident").append("svg")
      .attr("width", 400)
      .attr("height", height/ 2)
      .append("g")
      .attr("transform", "translate(" + 200 + "," + ((height / 3) - 50) + ")");

  var ring = svg.selectAll(".ring")
      .data(data)
      .enter().append("g")
        .attr("class", "ring");
        // .style("cursor", "pointer");   // add this back to show the number

  var inp_ring = inp_svg.selectAll(".inp_ring")
      .data(inp_data)
      .enter().append("g")
        .attr("class", "inp_ring")
        .style("cursor", "pointer");

  ring.append("path")
      .attr("class", "patch")
      .attr("fill", function(d) { return color(d.value); })
      .attr("stroke", 'black')
      .attr("stroke-width", 1)  
      .attr("d", function(d) {
          return arc
            .innerRadius(d.innerRadius)
            .outerRadius(d.outerRadius)
            .startAngle(d.startAngle)
            .endAngle(d.endAngle)(); });

  inp_ring.append("path")
      .attr("class", "inp_patch")
      .attr("fill", function(d) { return d.selected ? 'yellow' : 'gray'; })
      .attr("stroke", 'black')
      .attr("stroke-width", function(d) { return d.selected ? 3 : 1; })  
      .attr("d", function(d) {
          return arc
            .innerRadius(d.innerRadius)
            .outerRadius(d.outerRadius)
            .startAngle(d.startAngle)
            .endAngle(d.endAngle)(); })
            .on('click', update_graph_on_click);

  ring.append("svg:title")
    .attr("class", "patchtitle")
    .text(function(d) { return d.value; });

  ring.append("text")
    .attr("class", "patch_id")
    .attr("transform", function(d) { 
      return d.id == 1 ? "translate(0,0)" : "translate(" + label.centroid(d) + ")";
    })
    .attr("dy", "0.35em")
    .attr("fill", "black")
    .text(function(d) { return d.id; });
  

  inp_ring.append("svg:title")
    .attr("class", "inp_patchtitle")
    .text(function(d) { return d.id; });

  // inp_ring.append("text")
  //   .attr("class", "inp_patch_id")
  //   .attr("transform", function(d) { 
  //     return d.id == 1 ? "translate(0,0)" : "translate(" + label.centroid(d) + ")";
  //   })
  //   .attr("dy", "0.35em")
  //   .attr("fill", "black")
  //   .text(function(d) { return d.id; });

  draw_legend('#legend', color);

  d3.select("div #filename").text(bsdf_path).style("color", "gray");

  add_directions_dropdown(directions);

  // add data as text
  updateCPText();
}


// update patch data in control panel
function updateCPText(){
  var total = 0;
  d3.selectAll(".patch").data().forEach(function(d){ total += d.value; });
  d3.select("div #selecteddir").text(directions[selectedDirection]);
  var info = "Incident Patch: " + selectedPatch + "    |   Direct Hemispherical: " + total.toFixed(3);
  d3.select("div #totalvalue").text(info);
}
  
// calculate ring number from patch front id
function ringNumber(frontId){
    if (frontId == 1) return 0;
  	for (var i = 0; i < counter_rev.length; i++){
        var v = counter_rev[i];
      	if (frontId > v) return 9 - i;
		}
}

function update_graph_on_click(){
  var p = d3.select(this);
  var data = p.data()[0];
  selectedPatch = data.id;

  // update existing hemisphere
  d3.selectAll(".patch")
  	.attr("stroke-width", 1)
    .attr("fill", function(d) {
      d.value = d.values[selectedDirection][selectedPatch - 1];
    	return color(d.value);
    });

  d3.selectAll(".patchtitle").text(function(d) { return d.value.toFixed(4); });

  d3.selectAll(".inp_patch")
  	.attr("stroke-width", 1)
    .attr("fill", function(d) {
    	d.selected = false;
    	return 'gray';
  });  

  data.selected = true;
  p.attr("fill", "yellow");
  p.attr("stroke-width", 3);

  updateCPText();
}

function update_on_new_file(parsed_data){
  directions = parsed_data.map(function(d){ return d.direction; });
  selectedDirection = selectedDirection % directions.length;
  add_directions_dropdown(directions);

  // update data
  d3.selectAll(".patch").data().forEach(
    function(da){
      da.values = parsed_data.map(function(d, i){
        var dirc = directions[i];
        return d.data.map(
          function(el){return el[da.id - 1];}
        )});
    }
  ); 
  
  d3.selectAll(".patch")
    .attr("fill", function(d) {
    	d.value = d.values[selectedDirection][selectedPatch - 1];
    	if (d.id == selectedPatch) v = d.value;
    	return color(d.value); });
  
  d3.selectAll(".patchtitle").text(function(d) { return d.value; });
  d3.select("div #filename").text('');
  updateCPText();
}

// load default bsdf
var bsdf_path = "bsdf/klems/blinds_20deg_noGlazing_Klems.xml";
// var bsdf_path = "https://gist.githubusercontent.com/mostaphaRoudsari/3731c1fa3879ea74e24adb6e1081b887/raw/3043c43b035afd2236a524aa9e38a9159eb8b70e/CS-TBK7-12_112916.xml";
load_xml_file(bsdf_path, init_page);
</script>
